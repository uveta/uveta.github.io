{
    "version": "https://jsonfeed.org/version/1",
    "title": "Uveta's blog â€¢ All posts by \"dotnet\" tag",
    "description": "Uveta's blog about all things Azure",
    "home_page_url": "https://www.uveta.io",
    "items": [
        {
            "id": "https://www.uveta.io/categories/blog/unclutter-startup-cs/",
            "url": "https://www.uveta.io/categories/blog/unclutter-startup-cs/",
            "title": "Unclutter Startup.cs",
            "date_published": "2021-12-18T14:00:09.000Z",
            "content_html": "<html><head></head><body><img src=\"/categories/blog/unclutter-startup-cs/calendar.jpg\" class=\"\" title=\"Advent calendar\">\n\n<p>Configuring service container and setting up request pipeline in ASP.NET Core can eat up a lot of lines of code, especially for more complex projects. A well-established way of doing this is using <em>Startup.cs</em> and its <code>ConfigureServices()</code> and <code>Configure()</code> methods. Although complete application setup can be packed into a single type, we must not forget about Single-responsibility principle. I wanted to show you a way to prevent startup from growing uncontrollably, by keeping different concerns separate from each other.</p>\n<p>One disclaimer though. ASP.NET Core 6 has rolled in and removed the need of having <em>Startup.cs</em> altogether. Despite that fact, I am sure the ideas presented in this post will be relevant, even in the new era.</p>\n<span id=\"more\"></span>\n\n<p><em>This post is part of <a href=\"https://www.csadvent.christmas/\">C# Advent Calendar 2021</a>. Cheers to <a href=\"https://twitter.com/mgroves\">Matthew D. Groves</a> for letting me participate!</em></p>\n<h2 id=\"Basic-principles\"><a href=\"#Basic-principles\" class=\"headerlink\" title=\"Basic principles\"></a>Basic principles</h2><p>We will apply two .NET features: <a href=\"https://docs.microsoft.com/en-us/aspnet/core/fundamentals/configuration/options\">Options pattern</a> and <a href=\"https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/extension-methods\">Extension methods</a>. Similar to how ASP.NET Core uses plugin architecture, we will utilize these features to separate concerns and leave heavy lifting to dependency injection container.</p>\n<p>One design standard, to keep in mind, is that almost all parts of ASP.NET Core are configured via <a href=\"https://docs.microsoft.com/en-us/dotnet/api/microsoft.extensions.options.ioptions-1\">IOptions<toptions></toptions></a> pattern. And, since all <code>IOptions&lt;TOptions&gt;</code> instances are part of service container, we can use <a href=\"https://docs.microsoft.com/en-us/aspnet/core/fundamentals/configuration/options#use-di-services-to-configure-options\">IConfigureOptions<toptions></toptions></a> or <a href=\"https://docs.microsoft.com/en-us/aspnet/core/fundamentals/configuration/options#options-post-configuration\">IPostConfigureOptions<toptions></toptions></a> to override any one of them.</p>\n<h2 id=\"MVC\"><a href=\"#MVC\" class=\"headerlink\" title=\"MVC\"></a>MVC</h2><p>Whether you are using Controllers only, or including Views or Razor Pages, MVC setup is more or less the same. The goal is to call <a href=\"https://docs.microsoft.com/en-us/dotnet/api/microsoft.extensions.dependencyinjection.mvcservicecollectionextensions.addcontrollers\">AddControllers()</a>, <a href=\"https://docs.microsoft.com/en-us/dotnet/api/microsoft.extensions.dependencyinjection.mvcservicecollectionextensions.addcontrollerswithviews\">AddControllersWithViews()</a> or <a href=\"https://docs.microsoft.com/en-us/dotnet/api/microsoft.extensions.dependencyinjection.mvcservicecollectionextensions.addrazorpages\">AddRazorPages()</a>, based on your scenario, and define configuration for <a href=\"https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.mvc.mvcoptions\">MvcOptions</a>, and possibly <a href=\"https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.mvc.razorpages.razorpagesoptions\">RazorPagesOptions</a>. If you are using <a href=\"https://docs.microsoft.com/en-us/dotnet/api/system.text.json.jsonserializer\">System.Text.Json</a> or <a href=\"https://www.nuget.org/packages/Microsoft.AspNetCore.Mvc.NewtonsoftJson\">Newtonsoft Json.NET</a> for model serialization, you could also configure them in a similar manner. Whole setup would look like this:</p>\n<figure class=\"highlight csharp hljs\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">MvcExtensions</span></span><br><span class=\"line\">{</span><br><span class=\"line\">    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> IServiceCollection <span class=\"hljs-title\">ConfigureMvc</span>(<span class=\"hljs-params\"><span class=\"hljs-keyword\">this</span> IServiceCollection services</span>)</span></span><br><span class=\"line\">    {</span><br><span class=\"line\">        services.AddControllers().AddNewtonsoftJson();</span><br><span class=\"line\">        services.AddSingleton&lt;IConfigureOptions&lt;MvcOptions&gt;, ConfigureMvcOptions&gt;();</span><br><span class=\"line\">        services.AddSingleton&lt;IConfigureOptions&lt;MvcNewtonsoftJsonOptions&gt;, ConfigureNewtonsoftOptions&gt;();</span><br><span class=\"line\">        <span class=\"hljs-keyword\">return</span> services;</span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">ConfigureMvcOptions</span> : <span class=\"hljs-title\">IConfigureOptions</span>&lt;<span class=\"hljs-title\">MvcOptions</span>&gt;</span><br><span class=\"line\">{</span><br><span class=\"line\">    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">Configure</span>(<span class=\"hljs-params\">MvcOptions options</span>)</span></span><br><span class=\"line\">    {</span><br><span class=\"line\">        options.SuppressAsyncSuffixInActionNames = <span class=\"hljs-literal\">true</span>;</span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">ConfigureNewtonsoftOptions</span> : <span class=\"hljs-title\">IConfigureOptions</span>&lt;<span class=\"hljs-title\">MvcNewtonsoftJsonOptions</span>&gt;</span><br><span class=\"line\">{</span><br><span class=\"line\">    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">Configure</span>(<span class=\"hljs-params\">MvcNewtonsoftJsonOptions options</span>)</span></span><br><span class=\"line\">    {</span><br><span class=\"line\">        options.SerializerSettings.Converters.Add(<span class=\"hljs-keyword\">new</span> StringEnumConverter());</span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n<h2 id=\"Authentication\"><a href=\"#Authentication\" class=\"headerlink\" title=\"Authentication\"></a>Authentication</h2><p>Completely driving authentication by configuration is difficult. You probably need to know what type of authentication your application uses in advance. Good news is that, once baseline is established, you can use above mentioned technique to configure individual parts. For example, you would use <a href=\"https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.authentication.cookies.cookieauthenticationoptions\">CookieAuthenticationOptions</a> to configure cookies, and <a href=\"https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.authentication.jwtbearer.jwtbeareroptions\">JwtBearerOptions</a> for token based authentication. Extension and individual configuration options, including an example of injecting IConfiguration into one of them, would look like this:</p>\n<figure class=\"highlight csharp hljs\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">AuthenticationExtensions</span></span><br><span class=\"line\">{</span><br><span class=\"line\">    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> IServiceCollection <span class=\"hljs-title\">ConfigureAuthentication</span>(<span class=\"hljs-params\"><span class=\"hljs-keyword\">this</span> IServiceCollection services</span>)</span></span><br><span class=\"line\">    {</span><br><span class=\"line\">        services.AddAuthentication().AddCookie().AddJwtBearer();</span><br><span class=\"line\">        services.AddSingleton&lt;IConfigureOptions&lt;AuthenticationOptions&gt;, ConfigureAuthenticationOptions&gt;();</span><br><span class=\"line\">        services.AddSingleton&lt;IConfigureOptions&lt;CookieAuthenticationOptions&gt;, ConfigureCookieAuthenticationOptions&gt;();</span><br><span class=\"line\">        services.AddSingleton&lt;IConfigureOptions&lt;JwtBearerOptions&gt;, ConfigureJwtBearerOptions&gt;();</span><br><span class=\"line\">        <span class=\"hljs-keyword\">return</span> services;</span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">ConfigureAuthenticationOptions</span> : <span class=\"hljs-title\">IConfigureOptions</span>&lt;<span class=\"hljs-title\">AuthenticationOptions</span>&gt;</span><br><span class=\"line\">{</span><br><span class=\"line\">    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">Configure</span>(<span class=\"hljs-params\">AuthenticationOptions options</span>)</span></span><br><span class=\"line\">    {</span><br><span class=\"line\">        options.DefaultAuthenticateScheme = JwtBearerDefaults.AuthenticationScheme;</span><br><span class=\"line\">        options.DefaultChallengeScheme = JwtBearerDefaults.AuthenticationScheme;</span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">ConfigureCookieAuthenticationOptions</span> : <span class=\"hljs-title\">IConfigureOptions</span>&lt;<span class=\"hljs-title\">CookieAuthenticationOptions</span>&gt;</span><br><span class=\"line\">{</span><br><span class=\"line\">    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">Configure</span>(<span class=\"hljs-params\">CookieAuthenticationOptions options</span>)</span></span><br><span class=\"line\">    {</span><br><span class=\"line\">        options.ExpireTimeSpan = TimeSpan.FromHours(<span class=\"hljs-number\">1</span>);</span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">ConfigureJwtBearerOptions</span> : <span class=\"hljs-title\">IConfigureOptions</span>&lt;<span class=\"hljs-title\">JwtBearerOptions</span>&gt;</span><br><span class=\"line\">{</span><br><span class=\"line\">    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">readonly</span> IConfiguration _configuration;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">ConfigureJwtBearerOptions</span>(<span class=\"hljs-params\">IConfiguration configuration</span>)</span></span><br><span class=\"line\">    {</span><br><span class=\"line\">        _configuration = configuration;</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">Configure</span>(<span class=\"hljs-params\">JwtBearerOptions options</span>)</span></span><br><span class=\"line\">    {</span><br><span class=\"line\">        options.Authority = _configuration.GetValue&lt;<span class=\"hljs-built_in\">string</span>&gt;(<span class=\"hljs-string\">\"jwt:authority\"</span>);</span><br><span class=\"line\">        options.RequireHttpsMetadata = <span class=\"hljs-literal\">false</span>;</span><br><span class=\"line\">        options.IncludeErrorDetails = <span class=\"hljs-literal\">true</span>;</span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n<h2 id=\"Authorization\"><a href=\"#Authorization\" class=\"headerlink\" title=\"Authorization\"></a>Authorization</h2><p>Configuring authorization can get quite tedious, if number or complexity of policies increases. Luckily, setup process is pretty straightforward, as the only concern is injecting configuration via <a href=\"https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.authorization.authorizationoptions\">AuthorizationOptions</a> type.</p>\n<figure class=\"highlight csharp hljs\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">AuthorizationExtensions</span></span><br><span class=\"line\">{</span><br><span class=\"line\">    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> IServiceCollection <span class=\"hljs-title\">ConfigureAuthorization</span>(<span class=\"hljs-params\"><span class=\"hljs-keyword\">this</span> IServiceCollection services</span>)</span></span><br><span class=\"line\">    {</span><br><span class=\"line\">        services.AddAuthorization();</span><br><span class=\"line\">        services.AddSingleton&lt;IConfigureOptions&lt;AuthorizationOptions&gt;, ConfigureAuthorizationOptions&gt;();</span><br><span class=\"line\">        <span class=\"hljs-keyword\">return</span> services;</span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">ConfigureAuthorizationOptions</span> : <span class=\"hljs-title\">IConfigureOptions</span>&lt;<span class=\"hljs-title\">AuthorizationOptions</span>&gt;</span><br><span class=\"line\">{</span><br><span class=\"line\">    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">Configure</span>(<span class=\"hljs-params\">AuthorizationOptions options</span>)</span></span><br><span class=\"line\">    {</span><br><span class=\"line\">        options.DefaultPolicy = <span class=\"hljs-keyword\">new</span> AuthorizationPolicyBuilder().RequireAuthenticatedUser().Build();</span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n<h2 id=\"OpenAPI\"><a href=\"#OpenAPI\" class=\"headerlink\" title=\"OpenAPI\"></a>OpenAPI</h2><p>If you care about your REST API consumers, you are publishing service description, using OpenAPI specification. And, since we are talking about ASP.NET Core, you are probably using awesome <a href=\"https://www.nuget.org/packages/Swashbuckle.AspNetCore\">Swashbuckle</a> package. As with previously mentioned framework parts, this extension was designed on same principles, and can be setup in a similar fashion. Whether its generating definition file using <code>SwaggerGenOptions</code>, or adjusting swagger user interface via <code>SwaggerUIOptions</code>, everything can be broken down and put into separate types.</p>\n<figure class=\"highlight csharp hljs\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">OpenApiExtensions</span></span><br><span class=\"line\">{</span><br><span class=\"line\">    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> IServiceCollection <span class=\"hljs-title\">ConfigureOpenApi</span>(<span class=\"hljs-params\"><span class=\"hljs-keyword\">this</span> IServiceCollection services</span>)</span></span><br><span class=\"line\">    {</span><br><span class=\"line\">        services.AddSwaggerGen();</span><br><span class=\"line\">        services.AddSwaggerGenNewtonsoftSupport();</span><br><span class=\"line\">        services.AddSingleton&lt;IConfigureOptions&lt;SwaggerGenOptions&gt;, ConfigureSwaggerGenOptions&gt;();</span><br><span class=\"line\">        services.AddSingleton&lt;IConfigureOptions&lt;SwaggerOptions&gt;, ConfigureSwaggerOptions&gt;();</span><br><span class=\"line\">        services.AddSingleton&lt;IConfigureOptions&lt;SwaggerUIOptions&gt;, ConfigureSwaggerUiOptions&gt;();</span><br><span class=\"line\">        <span class=\"hljs-keyword\">return</span> services;</span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">ConfigureSwaggerGenOptions</span> : <span class=\"hljs-title\">IConfigureOptions</span>&lt;<span class=\"hljs-title\">SwaggerGenOptions</span>&gt;</span><br><span class=\"line\">{</span><br><span class=\"line\">    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">Configure</span>(<span class=\"hljs-params\">SwaggerGenOptions options</span>)</span></span><br><span class=\"line\">    {</span><br><span class=\"line\">        options.SwaggerDoc(<span class=\"hljs-string\">\"v1\"</span>, <span class=\"hljs-keyword\">new</span> OpenApiInfo { Title = <span class=\"hljs-string\">\"Demo\"</span>, Version = <span class=\"hljs-string\">\"v1\"</span> });</span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">ConfigureSwaggerOptions</span> : <span class=\"hljs-title\">IConfigureOptions</span>&lt;<span class=\"hljs-title\">SwaggerOptions</span>&gt;</span><br><span class=\"line\">{</span><br><span class=\"line\">    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">Configure</span>(<span class=\"hljs-params\">SwaggerOptions options</span>)</span></span><br><span class=\"line\">    {</span><br><span class=\"line\">        options.RouteTemplate = <span class=\"hljs-string\">\"swagger/{documentName}/swagger.json\"</span>;</span><br><span class=\"line\">        options.PreSerializeFilters.Add((swaggerDoc, httpReq) =&gt;</span><br><span class=\"line\">        {</span><br><span class=\"line\">            swaggerDoc.Servers = <span class=\"hljs-keyword\">new</span>[] {</span><br><span class=\"line\">                <span class=\"hljs-keyword\">new</span> OpenApiServer {</span><br><span class=\"line\">                    Url = <span class=\"hljs-string\">$\"<span class=\"hljs-subst\">{httpReq.Scheme}</span>://<span class=\"hljs-subst\">{httpReq.Host.Value}</span><span class=\"hljs-subst\">{httpReq.PathBase}</span>\"</span>,</span><br><span class=\"line\">                    Description = <span class=\"hljs-string\">\"Default\"</span></span><br><span class=\"line\">                }</span><br><span class=\"line\">            };</span><br><span class=\"line\">        });</span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">ConfigureSwaggerUiOptions</span> : <span class=\"hljs-title\">IConfigureOptions</span>&lt;<span class=\"hljs-title\">SwaggerUIOptions</span>&gt;</span><br><span class=\"line\">{</span><br><span class=\"line\">    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">Configure</span>(<span class=\"hljs-params\">SwaggerUIOptions options</span>)</span></span><br><span class=\"line\">    {</span><br><span class=\"line\">        options.SwaggerEndpoint(<span class=\"hljs-string\">\"/swagger/v1/swagger.json\"</span>, <span class=\"hljs-string\">\"Demo v1\"</span>);</span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n<h2 id=\"Application-Insights\"><a href=\"#Application-Insights\" class=\"headerlink\" title=\"Application Insights\"></a>Application Insights</h2><p>How about some Azure extensions? Most of the time you will not even need them, as ASP.NET Core seamlessly integrates with most of Azure resources. However, one particular extension I recommend using are <a href=\"https://www.nuget.org/packages/Microsoft.ApplicationInsights.AspNetCore\">Application Insights</a>. You want to have application telemetry under control, and this package allows you to fine tune metrics and data that will be ingested by Azure. From setup point of view, there is nothing surprising:</p>\n<figure class=\"highlight csharp hljs\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">TelemetryExtensions</span></span><br><span class=\"line\">{</span><br><span class=\"line\">    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> IServiceCollection <span class=\"hljs-title\">ConfigureTelemetry</span>(<span class=\"hljs-params\"><span class=\"hljs-keyword\">this</span> IServiceCollection services</span>)</span></span><br><span class=\"line\">    {</span><br><span class=\"line\">        services.AddApplicationInsightsTelemetry();</span><br><span class=\"line\">        services.AddSingleton&lt;IConfigureOptions&lt;ApplicationInsightsServiceOptions&gt;, ConfigureApplicationInsights&gt;();</span><br><span class=\"line\">        <span class=\"hljs-keyword\">return</span> services;</span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">ConfigureApplicationInsights</span> : <span class=\"hljs-title\">IConfigureOptions</span>&lt;<span class=\"hljs-title\">ApplicationInsightsServiceOptions</span>&gt;</span><br><span class=\"line\">{</span><br><span class=\"line\">    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">Configure</span>(<span class=\"hljs-params\">ApplicationInsightsServiceOptions options</span>)</span></span><br><span class=\"line\">    {</span><br><span class=\"line\">        options.EnableHeartbeat = <span class=\"hljs-literal\">true</span>;</span><br><span class=\"line\">        options.EnableAppServicesHeartbeatTelemetryModule = <span class=\"hljs-literal\">true</span>;</span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n<h2 id=\"Extras\"><a href=\"#Extras\" class=\"headerlink\" title=\"Extras\"></a>Extras</h2><p>Youâ€™ve probably gotten the gist of it by now; use extension methods to extract service definitions, and options to do actual service configuration. For completeness, let me give you the rest of commonly used ASP.NET Core features, including types used for configuration.</p>\n<ul>\n<li>Default files middleware via <a href=\"https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.builder.defaultfilesextensions.usedefaultfiles\">UseDefaultFiles()</a> - <a href=\"https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.builder.defaultfilesoptions\">DefaultFilesOptions</a></li>\n<li>Static files middleware via <a href=\"https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.builder.staticfileextensions.usestaticfiles\">UseStaticFiles()</a> - <a href=\"https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.builder.staticfileoptions\">StaticFileOptions</a></li>\n<li>Cross-Origin Resource Sharing via <a href=\"https://docs.microsoft.com/en-us/dotnet/api/microsoft.extensions.dependencyinjection.corsservicecollectionextensions.addcors\">AddCors()</a> - <a href=\"https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.cors.infrastructure.corsoptions?view=aspnetcore-6.0\">CorsOptions</a></li>\n<li>API Versioning services via <a href=\"https://www.nuget.org/packages/Microsoft.AspNetCore.Mvc.Versioning\">AddApiVersioning() and AddVersionedApiExplorer()</a> - <a href=\"https://github.com/dotnet/aspnet-api-versioning/blob/master/src/Microsoft.AspNetCore.Mvc.Versioning.ApiExplorer/ApiExplorerOptions.cs\">ApiExplorerOptions</a> and <a href=\"https://github.com/dotnet/aspnet-api-versioning/blob/master/src/Common/Versioning/ApiVersioningOptions.cs\">ApiVersioningOptions</a></li>\n</ul>\n<h2 id=\"Application-code\"><a href=\"#Application-code\" class=\"headerlink\" title=\"Application code\"></a>Application code</h2><p>Last but not least, what about your own application code? I highly recommend following the same principles, in order to avoid having application setup in a single place. If you are using clean architecture, and have your code decoupled into layers, initialization could be as simple as:</p>\n<figure class=\"highlight csharp hljs\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">ApplicationExtensions</span></span><br><span class=\"line\">{</span><br><span class=\"line\">    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> IServiceCollection <span class=\"hljs-title\">ConfigureApplication</span>(<span class=\"hljs-params\"><span class=\"hljs-keyword\">this</span> IServiceCollection services</span>)</span></span><br><span class=\"line\">    {</span><br><span class=\"line\">        services</span><br><span class=\"line\">            .AddDomain()</span><br><span class=\"line\">            .AddApplicationServices()</span><br><span class=\"line\">            .AddRepositories()</span><br><span class=\"line\">            .AddIntegration();</span><br><span class=\"line\">        <span class=\"hljs-keyword\">return</span> services;</span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n<h2 id=\"Conclusion\"><a href=\"#Conclusion\" class=\"headerlink\" title=\"Conclusion\"></a>Conclusion</h2><p>I have shown you one neat little trick that I use all the time, when setting up any kind of application. It is important to remember Single-responsibility principle, even for this type of code. Having <em>Startup.cs</em> consisting of several hundreds, or even thousands lines, is nothing unheard of. And, sadly, is an obvious code smell.</p>\n<p>All code shown in this post was published to <a href=\"https://github.com/uveta/demo-unclutter-startup\">GitHub</a>, as a single ASP.NET Core 6 project.</p>\n</body></html>",
            "tags": [
                "azure",
                "dotnet",
                "advanced"
            ]
        },
        {
            "id": "https://www.uveta.io/categories/blog/asynchronous-job-pattern-the-asp-net-core-mvc-way/",
            "url": "https://www.uveta.io/categories/blog/asynchronous-job-pattern-the-asp-net-core-mvc-way/",
            "title": "Asynchronous Job Pattern - The ASP.NET Core MVC Way",
            "date_published": "2020-12-21T20:33:44.000Z",
            "content_html": "<html><head></head><body><img src=\"/categories/blog/asynchronous-job-pattern-the-asp-net-core-mvc-way/calendar.jpg\" class=\"\" title=\"Advent calendar\">\n\n<p>Let me present a pattern we used to solve a problem haunting our enterprise application for ages. It was initially designed to handle long running operations, using <a href=\"http://restalk-patterns.org/long-running-operation-polling.html\">RESTful approach</a>, but we soon realized it could be used in many other ways. As it generalizes the system of submitting requests and obtaining responses, it can easily be adapted to different business processes, while keeping unified client interface.</p>\n<span id=\"more\"></span>\n\n<p><em>This post is part of <a href=\"https://www.csadvent.christmas/\">C# Advent Calendar 2020</a>. Cheers to <a href=\"https://twitter.com/mgroves\">Matthew D. Groves</a> for letting me participate!</em></p>\n<h2 id=\"Building-blocks\"><a href=\"#Building-blocks\" class=\"headerlink\" title=\"Building blocks\"></a>Building blocks</h2><p>From a <em>client</em> perspective, the pattern usage is pretty simple: it submits a <em>job</em> for processing to an <em>endpoint</em>; <em>job</em> status is polled until processing is finished; if status was successful, client uses <em>endpoint</em> to obtain output.</p>\n<p>On server side, several components are required to achieve such functionality. Lets take a look at the big picture and define individual pattern pieces.</p>\n<h3 id=\"Job\"><a href=\"#Job\" class=\"headerlink\" title=\"Job\"></a>Job</h3><p>A <em>job</em> is a principal entity, representing <em>client</em> intent processed by a designated <em>worker</em>. It is composed of:</p>\n<ul>\n<li><strong>Header</strong>, containing job metadata such as unique identifier, current status, time of creation/start/finish, potential issues as well as estimated time of completion</li>\n<li><strong>Input parameters</strong></li>\n<li><strong>Output values</strong></li>\n</ul>\n<h3 id=\"Worker\"><a href=\"#Worker\" class=\"headerlink\" title=\"Worker\"></a>Worker</h3><p>Component that does heavy lifting. Main responsibility is actual processing, as each <em>worker</em> is able to handle specific <em>job</em> type. In simple terms, we can describe it as a function accepting input parameters and returning either <em>job</em> output or an error.</p>\n<h3 id=\"Endpoint\"><a href=\"#Endpoint\" class=\"headerlink\" title=\"Endpoint\"></a>Endpoint</h3><p>Serves as an entry-point for <em>clients</em>. After creating a job, <em>client</em> should be able to obtain <em>job</em> status at any point in time, as well as output after processing is finished. <em>Endpoint</em> should also allow <em>client</em> to cancel and clean-up a <em>job</em>. Hence, it needs to provide following services:</p>\n<ul>\n<li>Create <em>job</em></li>\n<li>Get <em>job</em> status</li>\n<li>Get <em>job</em> output</li>\n<li>Delete <em>job</em></li>\n</ul>\n<h3 id=\"Job-Repository-and-Queue\"><a href=\"#Job-Repository-and-Queue\" class=\"headerlink\" title=\"Job Repository and Queue\"></a>Job Repository and Queue</h3><p>A <em>repository</em> will be used to store all <em>jobs</em>, which would allow both <em>endpoint</em> and <em>worker</em> to read and update <em>job</em> state. For now, letâ€™s consider <em>repository</em> an abstraction, as concrete implementation and storage technology may vary, depending on usage scenario.</p>\n<p>Binding between an <em>endpoint</em> and a <em>worker</em> would be achieved using a <em>job queue</em> concept. It has to provide a <em>producer</em> and a <em>consumer</em>, depending on the component using <em>queue</em> services. Similar to how <em>repository</em> was defined, implementation may range from memory one to a hyper-scale message broker. </p>\n<p>Final pattern architecture is depicted in the diagram bellow. As all core components are defined, we should move on to implementation using APS.NET Core.</p>\n<p><img src=\"architecture.png\" alt=\"Job pattern architecture\"></p>\n<h2 id=\"ASP-NET-Core-implementation\"><a href=\"#ASP-NET-Core-implementation\" class=\"headerlink\" title=\"ASP.NET Core implementation\"></a>ASP.NET Core implementation</h2><h3 id=\"Implementation-considerations\"><a href=\"#Implementation-considerations\" class=\"headerlink\" title=\"Implementation considerations\"></a>Implementation considerations</h3><p>In order to make the implementation as universal as possible, we need to limit <em>job</em> inputs and outputs to one of each. If multiple values are expected, they could be provided via a custom model. <code>JobExecutionResult</code> will serve as a wrapper for output value, containing result of <em>worker</em> execution and any possible issues. If we define them as types <code>TInput</code> and <code>TOutput</code>, our <em>worker</em> and <em>endpoint</em> could look something like this:</p>\n<script src=\"https://gist.github.com/uveta/85943b7354871239058c4b45ffca8ee9.js\"></script>\n<script src=\"https://gist.github.com/uveta/9ebe4d6514c8bf6d22dca908eeeb0c04.js\"></script>\n\n<p>As <em>endpoint</em> is user independent concept, it will be up to pattern to provide the implementation. On the other hand, <em>worker</em> is responsible for executing custom actions, hence itâ€™s implementation has to be provided by the pattern user. This reasoning will come into play during design, as we would like to provide plugin architecture for individual pattern components. This will allow utilizing only building blocks required for given scenario, while the user would provide implementation of required and customizable parts.</p>\n<h3 id=\"Plugging-in-worker-implementation\"><a href=\"#Plugging-in-worker-implementation\" class=\"headerlink\" title=\"Plugging in worker implementation\"></a>Plugging in worker implementation</h3><p><em>Worker</em> flow is straightforward: it should use <em>queue consumer</em> to listen for incoming <em>jobs</em>; whenever one is received, it should process it and update <em>job</em> status and output via <em>repository</em>; then it waits for next one and repeats previous steps. This cycle is supposed to run for the whole application lifetime, as new <em>jobs</em> can arrive at any time. A natural solution to implement such functionality are <a href=\"https://docs.microsoft.com/en-us/aspnet/core/fundamentals/host/hosted-services\">hosted services</a>. In our case, we could extract all common code (starting <em>queue consumer</em>, input/output serialization and <em>job</em> update) to a <code>WorkerInvoker&lt;TWorker&gt;</code> hosted service, bound to specific <em>worker</em> by it generic type <code>TWorker</code>.</p>\n<p>Adding <code>TWorker</code> type to DI container has multiple benefits. On one side, it can be injected into <code>WorkerInvoker&lt;TWorker&gt;</code>, removing the need to create it manually. On the other hand, it allows developers of <code>TWorker</code> to freely inject business services into it.</p>\n<h3 id=\"Exposing-endpoints\"><a href=\"#Exposing-endpoints\" class=\"headerlink\" title=\"Exposing endpoints\"></a>Exposing endpoints</h3><p>Since controllers are used as primary entry point into MVC applications, they are an obvious choice for coupling with <em>endpoints</em>. In this case, <a href=\"http://restalk-patterns.org/long-running-operation-polling.html\">initial description</a> should be followed to the letter, as we are in domain of HTTP REST operations. Hence, controllers should include following routes:</p>\n<ul>\n<li><strong>POST <em>/jobs</em></strong>: allows creating new jobs; responds with status <em>202 (Accepted)</em>, containing <em>job</em> resource <em>URL</em></li>\n<li><strong>GET <em>/jobs/{jobId}</em></strong>: resource <em>URL</em> can be used for polling <em>job</em> status, while in progress; when processing is finished, use <em>303 (See Other)</em> redirect to provide client with an output resource <em>URL</em></li>\n<li><strong>GET <em>/jobs/{jobId}/output</em></strong>: output resource <em>URL</em>; should return <em>200 (OK)</em> result containing output value, after <em>job</em> processing finishes; returns <em>404 (NotFound)</em> error otherwise</li>\n<li><strong>DELETE <em>/jobs/{jobId}</em></strong>: disposes of any reserved resources; client should call it after polling finishes and output is obtained; if not done by client, server should clean up old <em>jobs</em> automatically</li>\n</ul>\n<p>The burden of creating a controller should not fall on the user; it is the responsibility of the pattern itself, since each route functionality is known in advance. For this purpose we could implement a generic <code>JobsController&lt;TEndpoint&gt;</code>, which would be bound to specific <em>endpoint</em> via its type parameter <code>TEndpoint</code>.</p>\n<p>As multiple <em>endpoints</em> per service have to be supported, MVC requires providing different underlying type for each controller. This is not possible with our idea of using a generic one, as changing genericâ€™s type parameter does not change overall generic type. Instead, we should create individual controller type from base generic dynamically, using a bit of <a href=\"https://docs.microsoft.com/en-us/dotnet/api/system.reflection.emit.typebuilder\">TypeBuilder</a> reflection magic. Generated types could then be added to MVC using custom <a href=\"https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.mvc.applicationparts.iapplicationparttypeprovider\">IApplicationPartTypeProvider</a>.</p>\n<h3 id=\"Few-words-on-repository-and-queue\"><a href=\"#Few-words-on-repository-and-queue\" class=\"headerlink\" title=\"Few words on repository and queue\"></a>Few words on repository and queue</h3><p>Following how we defined <em>job repository</em> and <em>queue</em>, respecting interfaces would be:</p>\n<script src=\"https://gist.github.com/uveta/44ca3dfbba05536e5091fbc353b611ec.js\"></script>\n<script src=\"https://gist.github.com/uveta/585866e8ae67e75d7c65eac9cccb6d0b.js\"></script>\n\n<p>The pattern has to supply default memory implementation for both of them. Although this should suffice for test and single-service usage, it completely falls flat in any advanced scenarios. Hence, replacing default implementations must be allowed via extensions.</p>\n<h3 id=\"Configuring-job-services\"><a href=\"#Configuring-job-services\" class=\"headerlink\" title=\"Configuring job services\"></a>Configuring job services</h3><p>We should follow principals ASP.NET Core was build upon and adopt a plugin architecture in order to configure our pattern services. I used <a href=\"https://github.com/uveta/extensions-jobs/tree/main/samples/MvcDemo\">a sample project</a> to demonstrate how such behavior could be achieved. The following example includes definition of one <em>endpoint</em> and its bound <em>worker</em>.</p>\n<script src=\"https://gist.github.com/uveta/777c12716df3015ebc67a651916bea23.js\"></script>\n\n<p>In this case, <code>PingRequest</code> and <code>PingResponse</code> correspond to input and output types. <code>PingWorker</code> represents a custom implementation of <code>IWorker</code>, supplied by user. Other components (<em>endpoint</em>, <em>repository</em> and <em>queue</em>) are provided by pattern and only configured here.</p>\n<h2 id=\"Usage-alternatives\"><a href=\"#Usage-alternatives\" class=\"headerlink\" title=\"Usage alternatives\"></a>Usage alternatives</h2><p>Proposed implementation is just one of many possible, as well as its usage. All building blocks are introduced as abstract concepts, which can be adapted for different scenarios than initially intended. For example, an <em>endpoint</em> could be utilized to issue an RPC call without knowing the address of remote service; client would use <em>endpoint</em> to create a new job, which would reach designated <em>worker</em> via queue, effectively removing the need of individual services knowing other ones even exist. Only constraint is imposed by specific business feature, having strictly defined input and output.</p>\n<p>Further improvements can be introduced on <em>workers</em> as well. In order to use them in a real-world scenarios, there has to be a possibility of configuring their maximum scaling and execution period limits. This feature will have to be supported by <em>queue</em> implementation, as <em>worker</em> is invoked based on actions triggered by <em>queue consumer</em>.</p>\n<p>Finally, default memory implementations of <em>queue</em> and <em>repository</em> are only good for <a href=\"https://github.com/uveta/extensions-jobs/tree/main/samples/MvcDemo\">demonstration purposes</a>. <em>Repository</em> should offer some form of permanent external storage, especially if usage in multi-service applications is considered. Same goes for <em>queue</em>, as the need for underlying message broker is evident in even simple production scenarios.</p>\n<h2 id=\"Conclusion\"><a href=\"#Conclusion\" class=\"headerlink\" title=\"Conclusion\"></a>Conclusion</h2><p>In this article I explained which set of problems did we solve using long running job pattern. We also saw one of the ways to implement it, using ASP.NET Core MVC. As a final observation, I described how inner pattern components can be used outside of MVC, in any system that wants to generalize request/response flow and reduce service coupling.</p>\n<p>Source code and samples can be found on <a href=\"https://github.com/uveta/extensions-jobs\">Github</a>. Individual packages have also been published to <a href=\"https://www.nuget.org/packages/Uveta.Extensions.Jobs/\">nuget.org</a>, in case you would like to try them in your own application.</p>\n</body></html>",
            "tags": [
                "dotnet",
                "advanced",
                "microservices"
            ]
        }
    ]
}