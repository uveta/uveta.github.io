{
    "version": "https://jsonfeed.org/version/1",
    "title": "Uveta's blog • All posts by \"microservices\" tag",
    "description": "Uveta's blog about all things Azure",
    "home_page_url": "https://www.uveta.io",
    "items": [
        {
            "id": "https://www.uveta.io/categories/blog/asynchronous-job-pattern-the-asp-net-core-mvc-way/",
            "url": "https://www.uveta.io/categories/blog/asynchronous-job-pattern-the-asp-net-core-mvc-way/",
            "title": "Asynchronous Job Pattern - The ASP.NET Core MVC Way",
            "date_published": "2020-12-21T20:33:44.000Z",
            "content_html": "<html><head></head><body><img src=\"/categories/blog/asynchronous-job-pattern-the-asp-net-core-mvc-way/calendar.jpg\" class=\"\" title=\"Advent calendar\">\n\n<p>Let me present a pattern we used to solve a problem haunting our enterprise application for ages. It was initially designed to handle long running operations, using <a href=\"http://restalk-patterns.org/long-running-operation-polling.html\">RESTful approach</a>, but we soon realized it could be used in many other ways. As it generalizes the system of submitting requests and obtaining responses, it can easily be adapted to different business processes, while keeping unified client interface.</p>\n<span id=\"more\"></span>\n\n<p><em>This post is part of <a href=\"https://www.csadvent.christmas/\">C# Advent Calendar 2020</a>. Cheers to <a href=\"https://twitter.com/mgroves\">Matthew D. Groves</a> for letting me participate!</em></p>\n<h2 id=\"Building-blocks\"><a href=\"#Building-blocks\" class=\"headerlink\" title=\"Building blocks\"></a>Building blocks</h2><p>From a <em>client</em> perspective, the pattern usage is pretty simple: it submits a <em>job</em> for processing to an <em>endpoint</em>; <em>job</em> status is polled until processing is finished; if status was successful, client uses <em>endpoint</em> to obtain output.</p>\n<p>On server side, several components are required to achieve such functionality. Lets take a look at the big picture and define individual pattern pieces.</p>\n<h3 id=\"Job\"><a href=\"#Job\" class=\"headerlink\" title=\"Job\"></a>Job</h3><p>A <em>job</em> is a principal entity, representing <em>client</em> intent processed by a designated <em>worker</em>. It is composed of:</p>\n<ul>\n<li><strong>Header</strong>, containing job metadata such as unique identifier, current status, time of creation/start/finish, potential issues as well as estimated time of completion</li>\n<li><strong>Input parameters</strong></li>\n<li><strong>Output values</strong></li>\n</ul>\n<h3 id=\"Worker\"><a href=\"#Worker\" class=\"headerlink\" title=\"Worker\"></a>Worker</h3><p>Component that does heavy lifting. Main responsibility is actual processing, as each <em>worker</em> is able to handle specific <em>job</em> type. In simple terms, we can describe it as a function accepting input parameters and returning either <em>job</em> output or an error.</p>\n<h3 id=\"Endpoint\"><a href=\"#Endpoint\" class=\"headerlink\" title=\"Endpoint\"></a>Endpoint</h3><p>Serves as an entry-point for <em>clients</em>. After creating a job, <em>client</em> should be able to obtain <em>job</em> status at any point in time, as well as output after processing is finished. <em>Endpoint</em> should also allow <em>client</em> to cancel and clean-up a <em>job</em>. Hence, it needs to provide following services:</p>\n<ul>\n<li>Create <em>job</em></li>\n<li>Get <em>job</em> status</li>\n<li>Get <em>job</em> output</li>\n<li>Delete <em>job</em></li>\n</ul>\n<h3 id=\"Job-Repository-and-Queue\"><a href=\"#Job-Repository-and-Queue\" class=\"headerlink\" title=\"Job Repository and Queue\"></a>Job Repository and Queue</h3><p>A <em>repository</em> will be used to store all <em>jobs</em>, which would allow both <em>endpoint</em> and <em>worker</em> to read and update <em>job</em> state. For now, let’s consider <em>repository</em> an abstraction, as concrete implementation and storage technology may vary, depending on usage scenario.</p>\n<p>Binding between an <em>endpoint</em> and a <em>worker</em> would be achieved using a <em>job queue</em> concept. It has to provide a <em>producer</em> and a <em>consumer</em>, depending on the component using <em>queue</em> services. Similar to how <em>repository</em> was defined, implementation may range from memory one to a hyper-scale message broker. </p>\n<p>Final pattern architecture is depicted in the diagram bellow. As all core components are defined, we should move on to implementation using APS.NET Core.</p>\n<p><img src=\"architecture.png\" alt=\"Job pattern architecture\"></p>\n<h2 id=\"ASP-NET-Core-implementation\"><a href=\"#ASP-NET-Core-implementation\" class=\"headerlink\" title=\"ASP.NET Core implementation\"></a>ASP.NET Core implementation</h2><h3 id=\"Implementation-considerations\"><a href=\"#Implementation-considerations\" class=\"headerlink\" title=\"Implementation considerations\"></a>Implementation considerations</h3><p>In order to make the implementation as universal as possible, we need to limit <em>job</em> inputs and outputs to one of each. If multiple values are expected, they could be provided via a custom model. <code>JobExecutionResult</code> will serve as a wrapper for output value, containing result of <em>worker</em> execution and any possible issues. If we define them as types <code>TInput</code> and <code>TOutput</code>, our <em>worker</em> and <em>endpoint</em> could look something like this:</p>\n<script src=\"https://gist.github.com/uveta/85943b7354871239058c4b45ffca8ee9.js\"></script>\n<script src=\"https://gist.github.com/uveta/9ebe4d6514c8bf6d22dca908eeeb0c04.js\"></script>\n\n<p>As <em>endpoint</em> is user independent concept, it will be up to pattern to provide the implementation. On the other hand, <em>worker</em> is responsible for executing custom actions, hence it’s implementation has to be provided by the pattern user. This reasoning will come into play during design, as we would like to provide plugin architecture for individual pattern components. This will allow utilizing only building blocks required for given scenario, while the user would provide implementation of required and customizable parts.</p>\n<h3 id=\"Plugging-in-worker-implementation\"><a href=\"#Plugging-in-worker-implementation\" class=\"headerlink\" title=\"Plugging in worker implementation\"></a>Plugging in worker implementation</h3><p><em>Worker</em> flow is straightforward: it should use <em>queue consumer</em> to listen for incoming <em>jobs</em>; whenever one is received, it should process it and update <em>job</em> status and output via <em>repository</em>; then it waits for next one and repeats previous steps. This cycle is supposed to run for the whole application lifetime, as new <em>jobs</em> can arrive at any time. A natural solution to implement such functionality are <a href=\"https://docs.microsoft.com/en-us/aspnet/core/fundamentals/host/hosted-services\">hosted services</a>. In our case, we could extract all common code (starting <em>queue consumer</em>, input/output serialization and <em>job</em> update) to a <code>WorkerInvoker&lt;TWorker&gt;</code> hosted service, bound to specific <em>worker</em> by it generic type <code>TWorker</code>.</p>\n<p>Adding <code>TWorker</code> type to DI container has multiple benefits. On one side, it can be injected into <code>WorkerInvoker&lt;TWorker&gt;</code>, removing the need to create it manually. On the other hand, it allows developers of <code>TWorker</code> to freely inject business services into it.</p>\n<h3 id=\"Exposing-endpoints\"><a href=\"#Exposing-endpoints\" class=\"headerlink\" title=\"Exposing endpoints\"></a>Exposing endpoints</h3><p>Since controllers are used as primary entry point into MVC applications, they are an obvious choice for coupling with <em>endpoints</em>. In this case, <a href=\"http://restalk-patterns.org/long-running-operation-polling.html\">initial description</a> should be followed to the letter, as we are in domain of HTTP REST operations. Hence, controllers should include following routes:</p>\n<ul>\n<li><strong>POST <em>/jobs</em></strong>: allows creating new jobs; responds with status <em>202 (Accepted)</em>, containing <em>job</em> resource <em>URL</em></li>\n<li><strong>GET <em>/jobs/{jobId}</em></strong>: resource <em>URL</em> can be used for polling <em>job</em> status, while in progress; when processing is finished, use <em>303 (See Other)</em> redirect to provide client with an output resource <em>URL</em></li>\n<li><strong>GET <em>/jobs/{jobId}/output</em></strong>: output resource <em>URL</em>; should return <em>200 (OK)</em> result containing output value, after <em>job</em> processing finishes; returns <em>404 (NotFound)</em> error otherwise</li>\n<li><strong>DELETE <em>/jobs/{jobId}</em></strong>: disposes of any reserved resources; client should call it after polling finishes and output is obtained; if not done by client, server should clean up old <em>jobs</em> automatically</li>\n</ul>\n<p>The burden of creating a controller should not fall on the user; it is the responsibility of the pattern itself, since each route functionality is known in advance. For this purpose we could implement a generic <code>JobsController&lt;TEndpoint&gt;</code>, which would be bound to specific <em>endpoint</em> via its type parameter <code>TEndpoint</code>.</p>\n<p>As multiple <em>endpoints</em> per service have to be supported, MVC requires providing different underlying type for each controller. This is not possible with our idea of using a generic one, as changing generic’s type parameter does not change overall generic type. Instead, we should create individual controller type from base generic dynamically, using a bit of <a href=\"https://docs.microsoft.com/en-us/dotnet/api/system.reflection.emit.typebuilder\">TypeBuilder</a> reflection magic. Generated types could then be added to MVC using custom <a href=\"https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.mvc.applicationparts.iapplicationparttypeprovider\">IApplicationPartTypeProvider</a>.</p>\n<h3 id=\"Few-words-on-repository-and-queue\"><a href=\"#Few-words-on-repository-and-queue\" class=\"headerlink\" title=\"Few words on repository and queue\"></a>Few words on repository and queue</h3><p>Following how we defined <em>job repository</em> and <em>queue</em>, respecting interfaces would be:</p>\n<script src=\"https://gist.github.com/uveta/44ca3dfbba05536e5091fbc353b611ec.js\"></script>\n<script src=\"https://gist.github.com/uveta/585866e8ae67e75d7c65eac9cccb6d0b.js\"></script>\n\n<p>The pattern has to supply default memory implementation for both of them. Although this should suffice for test and single-service usage, it completely falls flat in any advanced scenarios. Hence, replacing default implementations must be allowed via extensions.</p>\n<h3 id=\"Configuring-job-services\"><a href=\"#Configuring-job-services\" class=\"headerlink\" title=\"Configuring job services\"></a>Configuring job services</h3><p>We should follow principals ASP.NET Core was build upon and adopt a plugin architecture in order to configure our pattern services. I used <a href=\"https://github.com/uveta/extensions-jobs/tree/main/samples/MvcDemo\">a sample project</a> to demonstrate how such behavior could be achieved. The following example includes definition of one <em>endpoint</em> and its bound <em>worker</em>.</p>\n<script src=\"https://gist.github.com/uveta/777c12716df3015ebc67a651916bea23.js\"></script>\n\n<p>In this case, <code>PingRequest</code> and <code>PingResponse</code> correspond to input and output types. <code>PingWorker</code> represents a custom implementation of <code>IWorker</code>, supplied by user. Other components (<em>endpoint</em>, <em>repository</em> and <em>queue</em>) are provided by pattern and only configured here.</p>\n<h2 id=\"Usage-alternatives\"><a href=\"#Usage-alternatives\" class=\"headerlink\" title=\"Usage alternatives\"></a>Usage alternatives</h2><p>Proposed implementation is just one of many possible, as well as its usage. All building blocks are introduced as abstract concepts, which can be adapted for different scenarios than initially intended. For example, an <em>endpoint</em> could be utilized to issue an RPC call without knowing the address of remote service; client would use <em>endpoint</em> to create a new job, which would reach designated <em>worker</em> via queue, effectively removing the need of individual services knowing other ones even exist. Only constraint is imposed by specific business feature, having strictly defined input and output.</p>\n<p>Further improvements can be introduced on <em>workers</em> as well. In order to use them in a real-world scenarios, there has to be a possibility of configuring their maximum scaling and execution period limits. This feature will have to be supported by <em>queue</em> implementation, as <em>worker</em> is invoked based on actions triggered by <em>queue consumer</em>.</p>\n<p>Finally, default memory implementations of <em>queue</em> and <em>repository</em> are only good for <a href=\"https://github.com/uveta/extensions-jobs/tree/main/samples/MvcDemo\">demonstration purposes</a>. <em>Repository</em> should offer some form of permanent external storage, especially if usage in multi-service applications is considered. Same goes for <em>queue</em>, as the need for underlying message broker is evident in even simple production scenarios.</p>\n<h2 id=\"Conclusion\"><a href=\"#Conclusion\" class=\"headerlink\" title=\"Conclusion\"></a>Conclusion</h2><p>In this article I explained which set of problems did we solve using long running job pattern. We also saw one of the ways to implement it, using ASP.NET Core MVC. As a final observation, I described how inner pattern components can be used outside of MVC, in any system that wants to generalize request/response flow and reduce service coupling.</p>\n<p>Source code and samples can be found on <a href=\"https://github.com/uveta/extensions-jobs\">Github</a>. Individual packages have also been published to <a href=\"https://www.nuget.org/packages/Uveta.Extensions.Jobs/\">nuget.org</a>, in case you would like to try them in your own application.</p>\n</body></html>",
            "tags": [
                "advanced",
                "dotnet",
                "microservices"
            ]
        }
    ]
}